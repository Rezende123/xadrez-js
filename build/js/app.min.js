const buildBoard = () => {
    const buildSquares = (row) => {
        let squares = []
        for (let column = 0; column < 8; column++) {
            squares.push(new ChessSquare(column, row))
        }

        return squares
    }
    const buildRows = () => {
        const rows = []
        for (let row = 0; row < 8; row++) {
            const squares = buildSquares(row) 
            const chessRow = new ChessRow(squares)
            
            rows.push(squares)
            board.appendChild(chessRow.element)
        }

        return rows
    }
    const board = document.querySelector('[board]')
    
    return buildRows()
}

function Game(chessRows) {
    this.rows = chessRows
    const blackTimeRows = chessRows.slice(0, 2)
    const whiteTimeRows = chessRows.slice(6)

    const insertParts = (color, rows) => {
        const team = []
        const addToTeam = (part) => {
            team.push(part)
        }
        rows.forEach((squares, index) => {
            if (color === 'b' && index === 0 || color === 'w' && index === 1) {
                addToTeam( new Tower(squares[0], color) )
                addToTeam( new Horse(squares[1], color) )
                addToTeam( new Bishp(squares[2], color) )
                addToTeam( new King(squares[3], color) )
                addToTeam( new Queen(squares[4], color) )
                addToTeam( new Bishp(squares[5], color) )
                addToTeam( new Horse(squares[6], color) )
                addToTeam( new Tower(squares[7], color) )
            } else
            if (color === 'b' && index === 1 || color === 'w' && index === 0) {
                squares.forEach(square => addToTeam( new Pawn(square, color) ))
            }
        });

        return team
    }
    this.setTurn = (team, turn, rivals, isCheck) => team.forEach(part => {
        part.gameRows = this.rows
        part.turn = turn
        part.rivals = rivals
        part.isCheck = isCheck
    })
    this.isFinish = false
    this.isCheck = (team, rivals) => {
        let kingInRisk = false
        const king = team.find(part => part.__proto__.constructor.name === 'King')

        const simulateTurn = rival => {
            rival.gameRows = this.rows
            rival.rivals = [king]
            rival.turn = 'test'
            rival.walking()

            const killRisk = Array.from(document.querySelectorAll('[kill-risk]'))
            const thisRivalIsRisk = killRisk.find(option => option.id == king.square.element.id)

            kingInRisk = thisRivalIsRisk || kingInRisk

            if (thisRivalIsRisk && kingInRisk) {
                rival.square.element.setAttribute('save-king', '')
            }

            const clearKillRisk = (option) => option.removeAttribute('kill-risk')
            killRisk.forEach(clearKillRisk)

            rival.removeDivOptions()
        }
        rivals.forEach(simulateTurn)

        const resetRivals = rival => {
            rival.gameRows = null
            rival.rivals = null
            rival.turn = null
        }
        rivals.forEach(resetRivals)
        
        const squareSaveKing = Array.from(document.querySelectorAll('[save-king]'))
        
        if (kingInRisk) {
            kingInRisk.classList.add('check')
            
            if (!squareSaveKing.length) {
                const checkKillMessage = document.getElementById('check-kill')
                checkKillMessage.classList.remove('hide') 
                this.isFinish = true
            }
        } else {
            squareSaveKing.forEach(square => square.removeAttribute('save-king'))
            
            const squareInCheck = document.querySelector('.check')

            if (squareInCheck) {
                squareInCheck.classList.remove('check')
            }
        }

        return !!kingInRisk // Para converter o valor para booleano
    }
    this.play = async () => {
        this.blackTeam = insertParts('b', blackTimeRows)
        this.whiteTeam = insertParts('w', whiteTimeRows)
        let countTurn = 0
        const turn = (team, rivals, isCheck = false) => {
            return new Promise((res, rej) => {
                this.setTurn(team, res, rivals, isCheck)
            })
        }
        
        while(!this.isFinish) {
            const team = (countTurn % 2 == 0) ? this.blackTeam : this.whiteTeam
            const rivals = (countTurn % 2 == 0) ? this.whiteTeam : this.blackTeam
            const isCheck = this.isCheck(team, rivals)

            await turn(team, rivals, isCheck)
            this.setTurn(team, null)

            const removeDeads = (_rivals) => {
                let index = _rivals.findIndex(rival => !rival.square);
                if (index > -1) {
                    _rivals.splice(index, 1);
                }
            }

            removeDeads(rivals)
            
            countTurn++
        }

    }
}

const chessRows = buildBoard()
const game = new Game(chessRows)
game.play()//.then(res => console.log(res))
function ChessSquare(column, row, element) {
    this.row = row
    this.column = column
    
    this.getId = () => id
    this.idFormatter = (column, row) => `r${row}c${column}`
    this.decodeId = (id) => {
        const cutedElement = id.split('c')
        const column = cutedElement[1]
        const row = cutedElement[0].split('r')[1]
    
        return [Number(column), Number(row)]
    }
    
    if (!element) {
        const id = this.idFormatter(column, row)   
        const div = document.createElement('div')
        div.setAttribute('chess-square','')
        div.setAttribute('id', id)
        
        this.element = div
    } else {
        this.element = element
    }
}

function ChessRow(squares) {
    const div = document.createElement('div')
    div.setAttribute('chess-row','')

    if (squares && squares.length) {
        squares
            .map(square => square.element)
            .forEach(square => {
                div.appendChild(square)
            });
    }

    this.element = div
}
function createPartImage (imgName) {
    const img = document.createElement('img')
    img.src = `assets/${imgName}.png`
    img.classList.add('img-part')

    return img
}
function createDivOption(callback, isKill) {
    const div = document.createElement('div')
    div.classList.add('walk-option')

    if (isKill) {
        div.classList.add('kill-option')
    }

    div.classList.add('cursor')
    div.setAttribute('play-option', '')

    div.onclick = (e) => callback(e.target.parentNode)

    return div
}

// Peças, a função pai que todas as outras funções vão herdar
function Part(square, imgName) {
    this.img = createPartImage(imgName)
    this.imgName = imgName

    this.turn = null
    this.gameRows = null
    this.rivals = null
    this.isCheck = false
    
    this.isRival = (elementId) => 
        this.rivals
        .find(rival => rival.square && rival.square.element.id == elementId)
    
    this.walkOptions = (option) => {
        if (!this.isCheck ||
            (
                this.isCheck &&
                option.getAttribute('save-king') != null &&
                this.__proto__.constructor.name != 'King'
            ) || 
            (
                this.isCheck &&
                option.getAttribute('save-king') == null &&
                this.__proto__.constructor.name == 'King'
            )
        ) {
            const markOption = createDivOption(this.move)
            
            option.appendChild( markOption )
        }
    }
    this.killOptions = (option, markedWalkOptions) => {
        if (
            option && option.element && this.isRival(option.element.id) &&
            (!this.isCheck || (this.isCheck && option.element.getAttribute('save-king') != null))
        ) {

            if (this.turn == 'test' && markedWalkOptions) { // Ocorre apenas na busca do rei
                markedWalkOptions.forEach(marked => marked.setAttribute('save-king', ''))
            }

            const markOption = createDivOption(this.killRival, true)
            option.element.appendChild( markOption )
            option.element.setAttribute('kill-risk', '')
        }
    }
    this.removeDivOptions = () => {
        const options = Array.from(document.querySelectorAll('[play-option]'))
        options.forEach(option => option.remove())
    }
    this.clearSquare = () => {
        this.square.element.removeAttribute('kill-risk')
        this.square.element.classList.remove('cursor');
        this.square.element.innerHTML = ''
        this.square.element.onclick = null
    }
    this.setSquare = (_square) => {
        _square.element.classList.add('cursor')
        _square.element.appendChild(this.img)
        
        this.square = _square
    }
    this.move = (element) => {
        this.removeDivOptions()
        
        const [column, row] = this.square.decodeId(element.id)
        const chessSquare = new ChessSquare(column, row, element)

        this.clearSquare()
        this.setSquare(chessSquare)
        this.square.element.onclick = this.walking

        this.isFirstStep = false

        this.turn(this.square)
    }
    this.killRival = (element) => {
        const rival = this.rivals.find(rival => rival.square && rival.square.element.id == element.id)
        const deadZoneId = (this.color == 'b') ? '#player2' : '#player1'
        const deadZone = document.querySelector(deadZoneId)

        rival.square = null
        deadZone.appendChild(rival.img)

        this.move(element)
    }
    this.setSquare(square)
}

// Torre
function Tower(square, color = 'b') {
    Part.call(this, square, `${color}_torre`) // Herança

    this.color = color

    this.walking = () => {
        if (!this.turn) return

        const column = this.square.column
        const row = this.square.row

        this.removeDivOptions()

        const markOptions = () => {
            const horizontal = () => {
                const scanner = (direction) => {
                    let index = column + (1 * direction)
                    let option = this.gameRows[row][index]
                    let markedWalkOptions = []

                    while(option && option.element && !option.element.children.length) {
                        this.walkOptions(option.element)
                        markedWalkOptions.push(option.element)

                        index += (1 * direction)
                        option = this.gameRows[row][index]
                    }
                    this.killOptions(option, markedWalkOptions)
                }
                // Left
                scanner(-1)
                // Right
                scanner(1) 
            }
            const vertical = () => {
                const scanner = (direction) => {
                    let index = row + (1 * direction)
                    if (this.gameRows[index]) {
                        let option = this.gameRows[index][column]
                        let markedWalkOptions = []
    
                        while(option && option.element && !option.element.children.length) {
                            this.walkOptions(option.element)
                            markedWalkOptions.push(option.element)

                            index += (1 * direction)
                            if (this.gameRows[index]) {
                                option = this.gameRows[index][column]
                            } else {
                                option = null
                            }
                        }
                        this.killOptions(option, markedWalkOptions)
                    }
                }
                // Left
                scanner(-1)
                // Right
                scanner(1) 
            }

            horizontal()
            vertical()
        }
        
        markOptions()
    }

    this.square.element.onclick = this.walking
}

// Cavalo
function Horse(square, color = 'b') {
    Part.call(this, square, `${color}_cavalo`) // Herança

    this.color = color

    this.walking = () => {
        if (!this.turn) return

        const column = this.square.column
        const row = this.square.row

        this.removeDivOptions()

        const markOptions = () => {
            const vertical = () => {
                const scanner = (orientation, side) => {
                    if (this.gameRows[row + side] &&
                        this.gameRows[row + side][column + orientation]) {
                        const option = this.gameRows[row + side][column + orientation]

                        if (!option.element.children.length) {
                            const element = option.element
                            this.walkOptions(element)
                        } else {
                            this.killOptions(option)
                        }
                    }
                }
                scanner(2, 1)
                scanner(2, -1)
                scanner(-2, 1)
                scanner(-2, -1)
            }
            const horizontal = () => {
                const scanner = (orientation, side) => {
                    if (this.gameRows[row + orientation] &&
                        this.gameRows[row + orientation][column + side]) {
                        const option = this.gameRows[row + orientation][column + side]

                        if (!option.element.children.length) {
                            const element = option.element
                            this.walkOptions(element)
                        } else {
                            this.killOptions(option)
                        }
                    }
                }
                scanner(2, 1)
                scanner(2, -1)
                scanner(-2, 1)
                scanner(-2, -1)
            }

            vertical()
            horizontal()
        }

        markOptions()
    }

    this.square.element.onclick = this.walking
}

// Bispo
function Bishp(square, color = 'b') {
    Part.call(this, square, `${color}_bispo`) // Herança

    this.color = color

    this.walking = () => {
        if (!this.turn) return
    
        const column = this.square.column
        const row = this.square.row
    
        this.removeDivOptions()

        const markOptions = () => {
            const diagonal = (direction, sense) => {
                let indexRow = row + (1 * sense)
                let indexColumn = column + (1 * direction)
                const isValidSquare = () =>
                    this.gameRows[indexRow] && this.gameRows[indexRow][indexColumn]

                if (isValidSquare()) {
                    let option = this.gameRows[indexRow][indexColumn]
                    let markedWalkOptions = []

                    while(option && option.element && !option.element.children.length) {
                        this.walkOptions(option.element)
                        markedWalkOptions.push(option.element)

                        indexRow += (1 * sense)
                        indexColumn += (1 * direction)
                        
                        if (isValidSquare()) {
                            option = this.gameRows[indexRow][indexColumn]
                        } else {
                            option = null
                        }
                    }

                    this.killOptions(option, markedWalkOptions)
                }
            }

            // Superior
            diagonal(1, -1)
            diagonal(1, 1)
            // Inferior
            diagonal(-1, -1)
            diagonal(-1, 1)
        }
        markOptions()
    }

    this.square.element.onclick = this.walking
}

// Rei
function King(square, color = 'b') {
    Part.call(this, square, `${color}_rei`) // Herança

    this.color = color

    this.walking = () => {
        if (!this.turn) return
    
        const column = this.square.column
        const row = this.square.row
    
        this.removeDivOptions()

        const markOptions = () => {
            const horizontal = () => {
                const scanner = (orientation) => {
                    if (this.gameRows[row][column + orientation]) {
                        const option = this.gameRows[row][column + orientation]

                        if (!option.element.children.length) {
                            const element = option.element
                            this.walkOptions(element)
                        } else {
                            this.killOptions(option)
                        }
                    }
                }
                scanner(1)
                scanner(-1)
            }
            const vertical = () => {
                const scanner = (orientation) => {
                    if (this.gameRows[row + orientation] &&
                        this.gameRows[row + orientation][column]) {
                        const option = this.gameRows[row + orientation][column]

                        if (!option.element.children.length) {
                            const element = option.element
                            this.walkOptions(element)
                        } else {
                            this.killOptions(option)
                        }
                    }
                }
                scanner(1)
                scanner(-1)
            }
            const diagonal = (direction, sense) => {
                let indexRow = row + (1 * sense)
                let indexColumn = column + (1 * direction)

                if (this.gameRows[indexRow] &&
                    this.gameRows[indexRow][indexColumn]) {
                    const option = this.gameRows[indexRow][indexColumn]

                    if (!option.element.children.length) {
                        const element = option.element
                        this.walkOptions(element)
                    } else {
                        this.killOptions(option)
                    }
                }
            }

            vertical()
            horizontal()

            // Superior
            diagonal(1, -1)
            diagonal(1, 1)
            // Inferior
            diagonal(-1, -1)
            diagonal(-1, 1)
        }

        markOptions()
    }

    this.square.element.onclick = this.walking
}

// Rainha
function Queen(square, color = 'b') {
    Part.call(this, square, `${color}_rainha`) // Herança

    this.color = color

    this.walking = () => {
        if (!this.turn) return
    
        const column = this.square.column
        const row = this.square.row
    
        this.removeDivOptions()

        const markOptions = () => {
            const diagonal = (direction, sense) => {
                let indexRow = row + (1 * sense)
                let indexColumn = column + (1 * direction)
                const isValidSquare = () =>
                    this.gameRows[indexRow] && this.gameRows[indexRow][indexColumn]

                if (isValidSquare()) {
                    let option = this.gameRows[indexRow][indexColumn]
                    let markedWalkOptions = []

                    while(option && option.element && !option.element.children.length) {
                        this.walkOptions(option.element)
                        markedWalkOptions.push(option.element)

                        indexRow += (1 * sense)
                        indexColumn += (1 * direction)
                        
                        if (isValidSquare()) {
                            option = this.gameRows[indexRow][indexColumn]
                        } else {
                            option = null
                        }
                    }
                    this.killOptions(option, markedWalkOptions)
                }
            }
            const horizontal = () => {
                const scanner = (direction) => {
                    let index = column + (1 * direction)
                    let option = this.gameRows[row][index]
                    let markedWalkOptions = []

                    while(option && option.element && !option.element.children.length) {
                        this.walkOptions(option.element)
                        markedWalkOptions.push(option.element)

                        index += (1 * direction)
                        option = this.gameRows[row][index]
                    }
                    this.killOptions(option, markedWalkOptions)
                }
                // Left
                scanner(-1)
                // Right
                scanner(1) 
            }
            const vertical = () => {
                const scanner = (direction) => {
                    let index = row + (1 * direction)
                    if (this.gameRows[index]) {
                        let option = this.gameRows[index][column]
                        let markedWalkOptions = []
    
                        while(option && option.element && !option.element.children.length) {
                            this.walkOptions(option.element)
                            markedWalkOptions.push(option.element)
    
                            index += (1 * direction)
                            if (this.gameRows[index]) {
                                option = this.gameRows[index][column]
                            } else {
                                option = null
                            }
                        }
                        this.killOptions(option, markedWalkOptions)
                    }
                }
                // Left
                scanner(-1)
                // Right
                scanner(1) 
            }

            horizontal()
            vertical()

            // Superior
            diagonal(1, -1)
            diagonal(1, 1)
            // Inferior
            diagonal(-1, -1)
            diagonal(-1, 1)
        }
        markOptions()
    }

    this.square.element.onclick = this.walking
}

// Peão
function Pawn(square, color = 'b') {
    Part.call(this, square, `${color}_peao`) // Herança
    
    this.isFirstStep = true
    this.color = color

    this.walking = () => {
        if (!this.turn) return

        const column = this.square.column
        const row = this.square.row
        
        this.removeDivOptions()
        
        const markOptions = (steps) => {
            const selectKillOptions = (sense) => {
                if (this.gameRows[newRow] &&
                    this.gameRows[newRow][column + sense] &&
                    this.gameRows[newRow][column + sense].element.children.length
                    ) {
                    const option = this.gameRows[newRow][column + sense]
    
                    this.killOptions(option)
                }
            }

            let newRow = 0
            for (let index = 1; index <= steps; index++) {
                const direction = (color == 'b')? 1 : -1
                newRow = row  + (direction * index) 

                if (this.gameRows[newRow] && this.gameRows[newRow][column]) {
                    const option = this.gameRows[newRow][column].element
    
                    if (!option.children.length) {
                        this.walkOptions(option)
                    }
                }

                selectKillOptions(1)
                selectKillOptions(-1)
            }
        }

        if (this.isFirstStep) {
            markOptions(2)
        } else {
            markOptions(1)
        }
    }
    this.square.element.onclick = this.walking
}
